<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="bubbleCanvas"></canvas>
    <script src="mocked.js"></script>
    <script src="utls.js"></script>
    <script src="data.js"></script>
    <script>
        const canvas = document.getElementById('bubbleCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const EVT_PROBABILITY = 0.1;
        const POP_PROBABILITY = 0.15;
        const RADIUS_INCREASE_UNIT = 8;
        const NO_TOKENS = 10;
        const POP_ITERATION = 50;
        let bubbles = [];
        let accs = [];
        let promiseQ = [];
        const client = new SolProxyClient();
        let globalInit = false;
        let globalQInit = false;
        let globalPop = false;
        const globalMocked = false;

        function buildSolTransfer(smaller, larger) {
            const payload = {
                cmdData: {
                    instr: {
                        tournament: larger.metadata.tournament,
                        source: larger.metadata.token.owner,
                        dest: smaller.metadata.token.owner,
                    }
                }
            };
            console.log('buildSolTransfer()', 'payload', payload);

            const promiseFactory = () => client.transferSol(payload, globalMocked)
                .then(data => {
                    console.log('buildSolTransfer()', 'promiseFactory', 'data', data);
                    // remove this promise from queue...
                    promiseQ = promiseQ.filter(i => i.id !== payload.id);
                    // kickoff the next one...
                    if (promiseQ.length) {
                        promiseQ[0].fn();
                    }
                })
                .catch(error => console.error('API call failed:', error));

            return new FnHandle(newId(), promiseFactory);
        }

        function buildNftTransfer(smaller, larger) {
            const payload = {
                cmdData: {
                    instr: {
                        tournament: larger.metadata.tournament,
                        source: smaller.metadata.token.owner,
                        dest: larger.metadata.token.owner,
                        mint: smaller.metadata.token.mint,
                    }
                }
            };
            console.log('buildNftTransfer()', 'payload', payload);

            const promiseFactory = () => client.transferNft(payload, globalMocked)
                .then(data => {
                    console.log('buildNftTransfer()', 'promiseFactory', 'data', data);
                    // remove this promise from queue...
                    promiseQ = promiseQ.filter(i => i.id !== payload.id);
                    // kickoff the next one...
                    if (promiseQ.length) {
                        promiseQ[0].fn();
                    }
                })
                .catch(error => console.error('API call failed:', error));

            return new FnHandle(newId(), promiseFactory);
        }

        function buildNftBurn(bubble) {
            const payload = {
                cmdData: {
                    instr: {
                        tournament: bubble.metadata.tournament,
                        source: bubble.metadata.token.owner,
                        mint: bubble.metadata.token.mint,
                    }
                }
            };
            console.log('buildNftBurn()', 'payload', payload);

            const promiseFactory = () => client.burnNft(payload, globalMocked)
                .then(data => {
                    console.log('buildNftBurn()', 'promiseFactory', 'data', data);
                    // remove this promise from queue...
                    promiseQ = promiseQ.filter(i => i.id !== payload.id);
                    // kickoff the next one...
                    if (promiseQ.length) {
                        promiseQ[0].fn();
                    }
                })
                .catch(error => console.error('API call failed:', error));

            return new FnHandle(newId(), promiseFactory);
        }

        function handleTransfer(smaller, larger) {
            if (globalMocked) {
                return;
            }

            const solT = buildSolTransfer(smaller, larger);
            const nftT = buildNftTransfer(smaller, larger);

            promiseQ.push(solT);
            promiseQ.push(nftT);

            if (!globalQInit) {
                promiseQ[0].fn();
                globalQInit = true;
            }
        }

        function handleBurn(bubble) {
            if (globalMocked) {
                return;
            }

            const t = buildNftBurn(bubble);

            promiseQ.push(t);

            if (!globalQInit) {
                promiseQ[0].fn();
                globalQInit = true;
            }
        }

        function handleCollision(b1, b2) {
            if (Math.random() >= EVT_PROBABILITY || !globalInit) {
                return;
            }

            if (globalPop) {
                return;
            }

            let larger = b1.radius > b2.radius ? b1 : b2;
            let smaller = b1.radius > b2.radius ? b2 : b1;

            // Larger radius increases by that of smaller...
            larger.radius += RADIUS_INCREASE_UNIT;
            bubbles = bubbles.filter(b => b !== smaller);

            handleTransfer(smaller, larger);
        }

        class FnHandle {
            constructor(id, fn) {
                this.id = id;
                this.fn = fn;
            }
        }

        class Metadata {
            constructor(token, tournament) {
                this.token = token;
                this.tournament = tournament;
            }
        }

        class Bubble {
            constructor(x, y, radius, metadata) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = (Math.random() - 0.5) * 2;
                this.dy = (Math.random() - 0.5) * 2;
                this.wobbleFactor = Math.random() * 0.2 + 0.1;
                this.color = 'lightgray';
                this.metadata = metadata;
                this.popIteration = 0;
                this.popping = false;
            }

            move() {
                if (this.popping) {
                    this.radius += 3;
                    this.popIteration++;
                    return;
                }

                this.x += this.dx;
                this.y += this.dy;
                this.dx += (Math.random() - 0.5) * this.wobbleFactor;
                this.dy += (Math.random() - 0.5) * this.wobbleFactor;
                this.handleBorderCollision();
            }

            handleBorderCollision() {
                if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) this.dx *= -1;
                if (this.y - this.radius <= 0 || this.y + this.radius >= canvas.height) this.dy *= -1;
            }

            draw() {
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, this.radius * 0.3,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                ctx.fillStyle = gradient;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.stroke();
            }
        }

        function detectCollisions() {
            for (let i = 0; i < bubbles.length; i++) {
                for (let j = i + 1; j < bubbles.length; j++) {
                    let b1 = bubbles[i];
                    let b2 = bubbles[j];
                    let dx = b2.x - b1.x;
                    let dy = b2.y - b1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < b1.radius + b2.radius) {
                        handleCollision(b1, b2);
                    }
                }
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            bubbles.forEach(bubble => {
                bubble.move();
                bubble.draw();
            });
            popped = bubbles.filter(bubble => bubble.popIteration >= POP_ITERATION);
            if (popped.length) {
                bubbles = bubbles.filter(bubble => bubble.popIteration < POP_ITERATION);
                for (const b of bubbles) {
                    handleBurn(b);
                }
                globalPop = false;
            }
            detectCollisions();
            requestAnimationFrame(animate);
        }

        function initBubblesData(setupData) {
            for (let i = 0; i < setupData.tokens.length; i++) {
                let radius = Math.random() * 30 + 10;
                let x = Math.random() * (canvas.width - radius * 2) + radius;
                let y = Math.random() * (canvas.height - radius * 2) + radius;

                const metadata = new Metadata(setupData.tokens[i], setupData.tournament);
                bubbles.push(new Bubble(x, y, radius, metadata));
            }
        }

        async function initBubbles() {
            const payload = {
                cmdData: {
                    instr: {
                        name: 'bc-2',
                        noTokens: NO_TOKENS,
                        fundAcc: true,
                    }
                }
            };
            const setupData = await client.setup(payload, globalMocked);
            initBubblesData(setupData);
        }

        function initAccsData(setupData) {
            console.log('initAccsData', 'setupData', setupData);
            accs = setupData;
        }

        async function initAccs() {
            const payload = {
                cmdData: {
                    instr: {
                        noAccs: NO_TOKENS,
                        useExisting: true,
                        fundAccs: true,
                    }
                }
            };
            const setupData = await client.createAccs(payload, globalMocked);
            console.log('initAccs', 'setupData', setupData);
            initAccsData(setupData);
        }

        async function initLink(acc, metadata) {
            const payload = {
                cmdData: {
                    instr: {
                        tournament: metadata.tournament,
                        mint: metadata.token.mint,
                        dest: acc, source: metadata.tournament,
                        useExisting: true
                    }
                }
            };
            console.log('initLink()', 'payload', payload);
            await client.transferNft(payload, globalMocked);

            const bubble = bubbles.filter(b => b.metadata.token.indx === metadata.token.indx)[0];
            bubble.color = getRandomColor();
            bubble.metadata.token.owner = acc;
        }

        async function initLinks() {
            await Promise.all(bubbles.map((v, i) => initLink(accs[i], v.metadata)));
        }

        async function init() {
            await Promise.all([initBubbles(), initAccs()])
            animate();
            await initLinks();
            globalInit = true;

            setInterval(() => {
                if (Math.random() > POP_PROBABILITY) {
                    return;
                }

                if (globalPop) {
                    return;
                }

                if (!bubbles.length) {
                    return;
                }

                globalPop = true;
                const bubble = bubbles[Math.floor(Math.random() * bubbles.length)];
                console.log('bubble to pop', bubble);
                bubble.popping = true
            }, 1000);
        }

        init()
            .then(
                () => console.log('init()', 'DONE!'),
                err => console.error('init()', 'ERROR', err)
            );

    </script>
</body>

</html>